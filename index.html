<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        * { box-sizing: border-box; }
        body { font-family: sans-serif; text-align: center; background: #111; color: white; margin: 0; padding: 0; display: flex; flex-direction: column; min-height: 100vh; }

        /* â”€â”€ GAME AREA â”€â”€ */
        #game-area { width: 100%; max-width: 480px; margin: 0 auto; padding: 6px 6px 0; }

        /* â”€â”€ SCORE BAR â”€â”€ */
        #score-bar { display: none; background: #1e1e1e; border-radius: 8px; padding: 5px 14px; margin-bottom: 4px; }
        .score-inner { display: flex; justify-content: space-between; align-items: center; }
        .score-label { color: #666; font-size: 10px; text-transform: uppercase; }
        .score-val { font-size: 18px; font-weight: bold; }
        .score-sep { color: #333; font-size: 20px; }

        /* â”€â”€ PLAYER ROWS â”€â”€ */
        .player-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 8px; background: #1a1a1a; border-radius: 6px; margin: 3px 0; }
        .player-name { font-size: 14px; font-weight: bold; color: #eee; display: flex; align-items: center; gap: 6px; }
        .color-dot { width: 9px; height: 9px; border-radius: 50%; display: inline-block; border: 1px solid #555; flex-shrink: 0; }
        .color-dot.white { background: #f0f0f0; }
        .color-dot.black { background: #444; border-color: #888; }
        .timer { font-size: 17px; font-family: monospace; background: #0d0d0d; padding: 3px 9px; border-radius: 4px; font-weight: bold; color: #eee; }

        /* â”€â”€ MATERIAL â”€â”€ */
        .material-row { display: flex; align-items: center; gap: 1px; flex-wrap: wrap; min-height: 14px; flex: 1; margin: 0 6px; }
        .mat-piece { width: 14px; height: 14px; display: inline-block; background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 0.85; }
        .mat-score { font-size: 10px; font-weight: bold; color: #aaa; margin-left: 2px; }
        .mat-score.positive { color: #81c784; }

        /* â”€â”€ BOARD â”€â”€ */
        #board { width: 100%; max-width: 480px; margin: 0 auto; touch-action: manipulation; }
        #board.pieces-flipped img { transform: rotate(180deg); transition: transform 0.25s ease; }
        #board:not(.pieces-flipped) img { transform: rotate(0deg); transition: transform 0.25s ease; }

        /* â”€â”€ STATUS â”€â”€ */
        #status { margin: 4px 0; font-weight: bold; padding: 6px; background: #1a1a1a; border-radius: 6px; font-size: 13px; color: #aaa; }

        /* â”€â”€ ACTION BAR â”€â”€ */
        .actions { display: flex; justify-content: center; gap: 6px; margin: 5px 0 6px; flex-wrap: wrap; }
        .action-btn { padding: 7px 13px; background: #2a2a2a; color: #ccc; border: 1px solid #333; border-radius: 20px; font-weight: bold; cursor: pointer; font-size: 12px; }
        .action-btn:active { opacity: 0.7; }
        .action-btn.danger { background: #1e0a0a; color: #ef9a9a; border-color: #4a1010; }
        .action-btn.secondary { background: #0a1020; color: #90caf9; border-color: #1a3050; }
        /* Call button always takes up space â€” visibility swap prevents layout snap */
        #call-btn { visibility: hidden; pointer-events: none; transition: background 0.2s, color 0.2s; }
        #call-btn.visible { visibility: visible; pointer-events: auto; }
        #call-btn.in-call { background: #1b3a1b !important; color: #66bb6a !important; border-color: #2d6a2d !important; }

        /* â”€â”€ BOTTOM UI â”€â”€ */
        #bottom-ui { max-width: 480px; margin: 0 auto; width: 100%; padding: 0 6px 80px; }

        /* â”€â”€ SETUP PANEL â”€â”€ */
        #setup-panel { background: #1a1a1a; border-radius: 14px; padding: 20px 16px; margin-top: 8px; }
        .setup-title { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .setup-subtitle { font-size: 13px; color: #666; margin-bottom: 16px; }
        .setup-row { display: flex; gap: 8px; margin-bottom: 10px; }
        .setup-row input { flex: 1; padding: 11px 12px; border-radius: 8px; border: 1px solid #333; background: #111; color: white; font-size: 14px; }
        .setup-row button { padding: 11px 18px; border-radius: 8px; background: #4CAF50; color: white; border: none; font-weight: bold; font-size: 14px; cursor: pointer; }
        .local-btn { width: 100%; padding: 10px; background: #1e1e1e; color: #888; border: 1px solid #2a2a2a; border-radius: 8px; font-size: 13px; cursor: pointer; margin-top: 6px; }
        .local-btn:hover { background: #252525; color: #aaa; }

        /* â”€â”€ LOBBY â”€â”€ */
        .lobby-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
        .lobby-you { display: flex; align-items: center; gap: 10px; }
        .lobby-avatar { width: 38px; height: 38px; border-radius: 50%; background: #4CAF50; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 17px; }
        .lobby-name { font-size: 16px; font-weight: bold; }
        .lobby-status { font-size: 11px; color: #4CAF50; }
        .lobby-connect { display: flex; flex-direction: column; gap: 8px; }
        .lobby-connect input, .lobby-connect select { padding: 11px 12px; border-radius: 8px; border: 1px solid #333; background: #111; color: white; font-size: 14px; width: 100%; }
        .connect-btn { width: 100%; padding: 11px; background: #4CAF50; color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; }

        /* â”€â”€ INVITE BOX â”€â”€ */
        #invite-link-box { background: #111; border: 1px solid #2a2a2a; border-radius: 10px; padding: 14px; }
        .invite-code-wrap { text-align: center; padding: 8px 0; }
        .logout-btn { background: #252525; color: #888; border: 1px solid #333; border-radius: 6px; padding: 6px 10px; font-size: 12px; cursor: pointer; }

        /* â”€â”€ IN-GAME PANEL â”€â”€ */
        #ingame-panel { margin-top: 6px; }

        /* â”€â”€ CHAT â”€â”€ */
        #chat-section { background: #1a1a1a; border-radius: 12px; overflow: hidden; margin-bottom: 6px; }
        .chat-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; background: #222; cursor: pointer; user-select: none; }
        .chat-header-left { display: flex; align-items: center; gap: 8px; font-weight: bold; font-size: 14px; }
        .chat-badge { background: #f44336; color: white; font-size: 10px; border-radius: 10px; padding: 1px 6px; display: none; }
        #chat-messages { height: 120px; overflow-y: auto; padding: 8px; text-align: left; background: #111; font-size: 13px; }
        .chat-msg { margin-bottom: 4px; line-height: 1.4; }
        .you  { color: #4CAF50; }
        .them { color: #64b5f6; }
        .sys  { color: #555; font-style: italic; }
        .chat-input-row { display: flex; gap: 6px; padding: 8px; }
        .chat-input-row input { flex: 1; padding: 8px 10px; border-radius: 6px; border: 1px solid #333; background: #222; color: white; font-size: 13px; }
        .chat-input-row button { padding: 8px 14px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 13px; }

        /* â”€â”€ FRIENDS BUTTON â”€â”€ */
        #friends-btn { position: fixed; bottom: 20px; right: 16px; z-index: 500; background: #1e1e1e; border: 1px solid #333; border-radius: 50%; width: 52px; height: 52px; font-size: 22px; cursor: pointer; box-shadow: 0 4px 16px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; padding: 0; }
        .friends-badge { position: absolute; top: -4px; right: -4px; background: #4CAF50; color: white; font-size: 10px; font-weight: bold; border-radius: 10px; padding: 1px 5px; }

        /* â”€â”€ DRAWER â”€â”€ */
        #drawer-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 600; }
        #drawer-overlay.show { display: block; }
        #friends-drawer { position: fixed; top: 0; right: -320px; width: 310px; height: 100vh; background: #1a1a1a; z-index: 700; transition: right 0.28s ease; display: flex; flex-direction: column; box-shadow: -6px 0 30px rgba(0,0,0,0.7); }
        #friends-drawer.open { right: 0; }
        .drawer-header { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: #222; border-bottom: 1px solid #2a2a2a; }
        .drawer-header h3 { margin: 0; font-size: 16px; }
        .drawer-close { background: none; border: none; color: #666; font-size: 20px; cursor: pointer; padding: 0; }
        .drawer-section { padding: 12px 14px; border-bottom: 1px solid #222; }
        .drawer-section label { font-size: 10px; color: #555; display: block; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
        .login-row { display: flex; gap: 6px; }
        .login-row input { flex: 1; padding: 8px 10px; border-radius: 6px; border: 1px solid #333; background: #111; color: white; font-size: 13px; }
        .login-row button, .add-friend-row button, .spectate-row button { padding: 8px 12px; font-size: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .logged-in-row { display: flex; align-items: center; gap: 8px; background: #111; border-radius: 8px; padding: 8px 10px; }
        .logged-in-avatar { width: 32px; height: 32px; border-radius: 50%; background: #4CAF50; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; flex-shrink: 0; }
        .logged-in-name { flex: 1; font-weight: bold; font-size: 14px; }
        .logged-in-status { font-size: 11px; color: #4CAF50; }
        .add-friend-row, .spectate-row { display: flex; gap: 6px; }
        .add-friend-row input, .spectate-row input { flex: 1; padding: 8px 10px; border-radius: 6px; border: 1px solid #333; background: #111; color: white; font-size: 13px; }
        #friend-list { flex: 1; overflow-y: auto; }
        .friend-item { display: flex; align-items: center; gap: 10px; padding: 10px 14px; cursor: pointer; transition: background 0.15s; }
        .friend-item:hover { background: #222; }
        .friend-avatar { width: 36px; height: 36px; border-radius: 50%; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 15px; color: white; }
        .friend-info { flex: 1; min-width: 0; text-align: left; }
        .friend-name { font-size: 14px; font-weight: bold; color: #eee; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .friend-status { font-size: 11px; margin-top: 2px; }
        .friend-status.online { color: #4CAF50; }
        .friend-status.playing { color: #FFB300; }
        .friend-status.offline { color: #444; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
        .status-dot.online { background: #4CAF50; }
        .status-dot.playing { background: #FFB300; animation: pulse-green 1.2s infinite; }
        .status-dot.offline { background: #333; }
        .friend-actions { display: flex; gap: 4px; }
        .friend-actions button { padding: 4px 8px; font-size: 11px; border-radius: 4px; border: none; cursor: pointer; font-weight: bold; color: white; }
        .btn-play-friend { background: #4CAF50; }
        .btn-spectate-friend { background: #1565C0; }
        .btn-remove-friend { background: #2a2a2a; color: #555; }
        .empty-friends { text-align: center; padding: 30px 14px; color: #444; font-size: 13px; }

        /* â”€â”€ SPECTATE BANNER â”€â”€ */
        #spectate-banner { display: none; background: #0d1433; border-bottom: 2px solid #1a237e; padding: 7px 14px; text-align: center; font-size: 13px; color: #7986cb; }
        #spectate-banner.show { display: block; }
        #spectate-banner b { color: #fff; }
        #spectate-banner button { background: #c62828; color: white; border: none; font-size: 11px; padding: 3px 8px; margin-left: 10px; border-radius: 4px; cursor: pointer; }

        /* â”€â”€ POPUPS â”€â”€ */
        button { cursor: pointer; }
        #game-end-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.82); z-index: 900; justify-content: center; align-items: center; }
        #game-end-overlay.show { display: flex; }
        #game-end-popup { background: #1e1e1e; border-radius: 18px; padding: 28px 24px; width: 290px; text-align: center; box-shadow: 0 8px 40px rgba(0,0,0,0.9); }
        .result-icon { font-size: 48px; margin-bottom: 10px; }
        .result-title { font-size: 22px; font-weight: bold; margin-bottom: 6px; }
        .result-sub { font-size: 13px; color: #666; margin-bottom: 20px; }
        .popup-buttons { display: flex; flex-direction: column; gap: 10px; }
        .popup-buttons button { width: 100%; padding: 12px; font-size: 14px; border-radius: 8px; border: none; font-weight: bold; color: white; }
        .btn-rematch { background: #4CAF50; }
        .btn-newgame { background: #2196F3; }
        .btn-close { background: #333; }

        /* â”€â”€ VOICE BAR â”€â”€ */
        #voice-bar { display: none; background: #1b3a1b; border: 1px solid #2d6a2d; border-radius: 8px; padding: 6px 12px; margin: 4px 0; align-items: center; justify-content: space-between; gap: 8px; }
        #voice-bar.show { display: flex; }
        .voice-status { font-size: 12px; color: #66bb6a; display: flex; align-items: center; gap: 5px; }
        .voice-dot { width: 8px; height: 8px; border-radius: 50%; background: #66bb6a; animation: pulse-green 1.2s ease-in-out infinite; }
        .voice-btns { display: flex; gap: 6px; }
        .voice-btns button { padding: 4px 9px; font-size: 12px; border-radius: 5px; border: none; color: white; cursor: pointer; font-weight: bold; }
        .btn-mute { background: #555; }
        .btn-mute.muted { background: #c62828; }
        .btn-hangup { background: #c62828; }

        /* â”€â”€ INCOMING CALL POPUP â”€â”€ */
        #call-popup { display: none; position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: #1b3a1b; border: 2px solid #4CAF50; border-radius: 14px; padding: 14px 20px; z-index: 1000; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.8); min-width: 260px; }
        #call-popup.show { display: block; }
        #call-popup p { margin: 0 0 10px; color: #ccc; font-size: 13px; }
        #call-popup .call-btns { display: flex; gap: 10px; justify-content: center; }
        #call-popup .call-btns button { padding: 9px 18px; border: none; border-radius: 6px; font-weight: bold; font-size: 13px; color: white; cursor: pointer; }

        /* â”€â”€ INVITE POPUP â”€â”€ */
        #invite-popup { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #1b3a1b; border: 2px solid #4CAF50; border-radius: 14px; padding: 14px 20px; z-index: 1000; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.8); min-width: 260px; }
        #invite-popup.show { display: block; }
        #invite-popup p { margin: 0 0 10px; color: #ccc; font-size: 13px; }
        #invite-popup .invite-btns { display: flex; gap: 10px; justify-content: center; }
        #invite-popup .invite-btns button { padding: 9px 18px; border: none; border-radius: 6px; font-weight: bold; font-size: 13px; color: white; }

        /* â”€â”€ PROMOTION â”€â”€ */
        #promo-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1100; justify-content: center; align-items: center; }
        #promo-overlay.show { display: flex; }
        #promo-box { background: #1e1e1e; border-radius: 14px; padding: 20px; text-align: center; box-shadow: 0 8px 40px rgba(0,0,0,0.9); }
        #promo-box p { margin: 0 0 14px; font-size: 14px; color: #aaa; }
        .promo-choices { display: flex; gap: 10px; justify-content: center; }
        .promo-btn { width: 64px; height: 64px; border: 2px solid #333; border-radius: 10px; background: #111; cursor: pointer; background-size: 80%; background-repeat: no-repeat; background-position: center; transition: border-color 0.15s, transform 0.1s; }
        .promo-btn:hover { border-color: #4CAF50; transform: scale(1.08); }

        /* â”€â”€ BOARD HIGHLIGHTS â”€â”€ */
        .square-55d63 { position: relative; }
        .highlight-square { box-shadow: inset 0 0 0 4px rgba(255,235,80,0.9) !important; }
        .last-move { background-color: rgba(255,240,120,0.35) !important; }
        .premove-from { background-color: rgba(255,120,120,0.22) !important; }
        .premove-to { background-color: rgba(255,120,120,0.15) !important; }
        .premove-select { box-shadow: inset 0 0 0 4px rgba(255,160,160,0.75) !important; }
        .ghost-piece { position: absolute; inset: 0; background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 0.42; pointer-events: none; z-index: 5; }
        .king-in-check { background: radial-gradient(ellipse at center, rgba(255,110,110,0.92) 0%, rgba(210,50,50,0.5) 55%, transparent 80%) !important; box-shadow: inset 0 0 0 3px rgba(255,130,130,0.95) !important; animation: check-pulse 0.8s ease-in-out infinite alternate; }
        @keyframes check-pulse { from { box-shadow: inset 0 0 0 3px rgba(255,130,130,0.9); } to { box-shadow: inset 0 0 0 4px rgba(255,170,170,1), 0 0 14px 4px rgba(255,80,80,0.55); } }
        @keyframes pulse-green { 0%,100%{opacity:1;} 50%{opacity:0.3;} }
        .legal-move::after { content:''; position:absolute; width:25%; height:25%; background:rgba(0,0,0,0.28); border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none; z-index:10; }
        .legal-move-capture::after { content:''; position:absolute; width:80%; height:80%; background:transparent; border:5px solid rgba(0,0,0,0.28); border-radius:50%; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none; z-index:10; }

        /* â”€â”€ SERVER CONFIG NOTE â”€â”€ */
        #server-note { font-size: 11px; color: #444; margin-top: 8px; padding: 6px; background: #0d0d0d; border-radius: 6px; }
        #server-note a { color: #4CAF50; }
    </style>
</head>
<body>

<!-- â•â•â• SPECTATE BANNER â•â•â• -->
<div id="spectate-banner">
    ğŸ‘ Spectating <b id="spectate-banner-name">â€”</b>
    <button onclick="stopSpectating()">âœ• Stop</button>
</div>

<!-- â•â•â• BOARD AREA â•â•â• -->
<div id="game-area">
    <div id="score-bar">
        <div class="score-inner">
            <div><div class="score-label" id="score-label-opp">Opponent</div><div class="score-val" id="score-opp">0</div></div>
            <div class="score-sep">â€“</div>
            <div><div class="score-label">Draw</div><div class="score-val" id="score-draw">0</div></div>
            <div class="score-sep">â€“</div>
            <div><div class="score-label" id="score-label-me">You</div><div class="score-val" id="score-me">0</div></div>
        </div>
    </div>

    <div class="player-row">
        <div class="player-name"><span class="color-dot" id="opp-dot"></span><span id="opp-name">Opponent</span></div>
        <div class="material-row" id="opp-material"></div>
        <div id="opponent-timer" class="timer">--:--</div>
    </div>

    <div id="board"></div>

    <div class="player-row">
        <div class="player-name"><span class="color-dot" id="me-dot"></span><span id="me-name">You</span></div>
        <div class="material-row" id="me-material"></div>
        <div id="player-timer" class="timer">--:--</div>
    </div>

    <div id="status">Tap below to connect or play locally</div>

    <!-- Voice call bar (shown when in call) -->
    <div id="voice-bar">
        <div class="voice-status"><div class="voice-dot"></div><span id="voice-status-text">In call</span></div>
        <div class="voice-btns">
            <button class="btn-mute" id="mute-btn" onclick="toggleMute()">ğŸ™ Mute</button>
            <button class="btn-hangup" onclick="hangupCall()">ğŸ“µ End</button>
        </div>
    </div>

    <div class="actions" id="game-actions" style="display:none;">
        <button onclick="flipBoard()" class="action-btn">ğŸ”„ Flip</button>
        <button class="action-btn secondary" id="call-btn" onclick="handleCallBtn()">ğŸ“ Call</button>
        <button class="action-btn" onclick="exportPGN()">ğŸ“‹ PGN</button>
        <button class="action-btn danger" onclick="resignGame()">ğŸ³ Resign</button>
    </div>
</div>

<!-- â•â•â• BOTTOM UI â•â•â• -->
<div id="bottom-ui">

    <div id="setup-panel">
        <!-- Login -->
        <div id="setup-login">
            <div class="setup-title">â™Ÿ Chess</div>
            <div class="setup-subtitle">Enter a username to play online</div>
            <div class="setup-row">
                <input type="text" id="my-key-input" placeholder="Your usernameâ€¦" maxlength="32" onkeydown="if(event.key==='Enter')setMyKey()">
                <button onclick="setMyKey()">Play</button>
            </div>
            <div id="server-note">
                âš ï¸ You must deploy the server first and set <code>SERVER_URL</code> in this file.<br>
                See the <b>SETUP GUIDE</b> below for free deployment on Render.com.
            </div>
            <button class="local-btn" onclick="startLocalGame()">ğŸ® Local 2-Player (offline)</button>
        </div>

        <!-- Lobby -->
        <div id="setup-lobby" style="display:none;">
            <div class="lobby-header">
                <div class="lobby-you">
                    <div class="lobby-avatar" id="lobby-avatar">?</div>
                    <div>
                        <div class="lobby-name" id="lobby-name">â€”</div>
                        <div class="lobby-status">ğŸŸ¢ Online</div>
                    </div>
                </div>
                <button class="logout-btn" onclick="doLogout()">Logout</button>
            </div>
            <div class="lobby-connect">
                <input type="text" id="friend-id" placeholder="Friend's usernameâ€¦" onkeydown="if(event.key==='Enter')connectToFriend()">
                <select id="time-control">
                    <option value="0">âˆ Unlimited</option>
                    <option value="60">1 min</option>
                    <option value="180">3 min</option>
                    <option value="300" selected>5 min</option>
                    <option value="600">10 min</option>
                </select>
                <button class="connect-btn" onclick="connectToFriend()">âš¡ Connect &amp; Play</button>
                <button class="connect-btn" id="create-link-btn" onclick="createInviteLink()" style="background:#1565C0;">ğŸ”— Create Game Link</button>
            </div>

            <div id="invite-link-box" style="display:none;">
                <div class="invite-code-wrap">
                    <div style="font-size:10px;color:#666;margin-bottom:3px;text-transform:uppercase;letter-spacing:.5px;">Game Code</div>
                    <div id="invite-code-display" style="font-size:22px;font-weight:bold;color:#4CAF50;letter-spacing:3px;font-family:monospace;"></div>
                    <div style="font-size:11px;color:#555;margin-top:2px;">Friend types this code to join</div>
                </div>
                <div style="display:flex;gap:6px;margin-top:8px;">
                    <button onclick="copyGameCode()" id="copy-code-btn" style="flex:1;padding:8px;font-size:12px;">ğŸ“‹ Copy Code</button>
                    <button onclick="shareInviteLink()" style="flex:1;padding:8px;font-size:12px;background:#4CAF50;">ğŸ“¤ Share Link</button>
                    <button onclick="cancelInviteLink()" style="padding:8px 12px;font-size:12px;background:#333;">âœ•</button>
                </div>
                <input type="hidden" id="invite-link-input">
                <div id="invite-waiting" style="font-size:11px;color:#FFB300;margin-top:6px;display:none;">â³ Waiting for friendâ€¦</div>
            </div>

            <button class="local-btn" onclick="startLocalGame()">ğŸ® Local 2-Player (offline)</button>
        </div>
    </div>

    <!-- In-game panel -->
    <div id="ingame-panel" style="display:none;">
        <div id="chat-section">
            <div class="chat-header" onclick="toggleChat()">
                <div class="chat-header-left"><span>ğŸ’¬ Chat</span><span class="chat-badge" id="chat-badge">â—</span></div>
                <span id="chat-arrow" style="font-size:12px;color:#aaa;">â–¼</span>
            </div>
            <div id="chat-body" style="display:none;">
                <div id="chat-messages"></div>
                <div class="chat-input-row">
                    <input type="text" id="chat-input" placeholder="Messageâ€¦" maxlength="200" onkeydown="if(event.key==='Enter')sendChat()">
                    <button onclick="sendChat()">Send</button>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- â•â•â• FRIENDS BUTTON â•â•â• -->
<button id="friends-btn" onclick="toggleDrawer()">
    ğŸ‘¥ <span class="friends-badge" id="friends-badge" style="display:none;">0</span>
</button>

<!-- â•â•â• DRAWER â•â•â• -->
<div id="drawer-overlay" onclick="toggleDrawer()"></div>
<div id="friends-drawer">
    <div class="drawer-header">
        <h3>ğŸ‘¥ Friends</h3>
        <button class="drawer-close" onclick="toggleDrawer()">âœ•</button>
    </div>
    <div class="drawer-section" id="drawer-login-section">
        <label>Your Account</label>
        <div id="drawer-logged-out">
            <div class="login-row">
                <input type="text" id="drawer-username-input" placeholder="Enter usernameâ€¦" maxlength="32" onkeydown="if(event.key==='Enter')drawerLogin()">
                <button onclick="drawerLogin()">Login</button>
            </div>
            <div style="font-size:11px;color:#555;margin-top:6px;">Saved in your browser</div>
        </div>
        <div id="drawer-logged-in" style="display:none;">
            <div class="logged-in-row">
                <div class="logged-in-avatar" id="drawer-avatar">?</div>
                <div>
                    <div class="logged-in-name" id="drawer-display-name">â€”</div>
                    <div class="logged-in-status">ğŸŸ¢ Online</div>
                </div>
                <button class="logout-btn" onclick="doLogout()">Logout</button>
            </div>
        </div>
    </div>
    <div class="drawer-section">
        <label>Add Friend</label>
        <div class="add-friend-row">
            <input type="text" id="add-friend-input" placeholder="Friend's usernameâ€¦" maxlength="32" onkeydown="if(event.key==='Enter')addFriend()">
            <button onclick="addFriend()">Add</button>
        </div>
    </div>
    <div class="drawer-section">
        <label>Spectate a Game</label>
        <div class="spectate-row">
            <input type="text" id="spectate-input" placeholder="Username to watchâ€¦" maxlength="32" onkeydown="if(event.key==='Enter')spectateByInput()">
            <button onclick="spectateByInput()">Watch</button>
        </div>
    </div>
    <div id="friend-list">
        <div class="empty-friends" id="empty-friends-msg">No friends added yet.<br>Add a friend above!</div>
    </div>
</div>

<!-- â•â•â• INCOMING CALL POPUP â•â•â• -->
<div id="call-popup">
    <p>ğŸ“ <b id="caller-name">Opponent</b> is callingâ€¦</p>
    <div class="call-btns">
        <button style="background:#4CAF50;" onclick="answerCall()">âœ… Answer</button>
        <button style="background:#f44336;" onclick="rejectCall()">âŒ Decline</button>
    </div>
</div>

<!-- Hidden audio for remote stream -->
<audio id="remote-audio" autoplay playsinline></audio>

<!-- â•â•â• INVITE POPUP â•â•â• -->
<div id="invite-popup">
    <p>â™Ÿï¸ <b id="invite-from-name">?</b> challenged you!</p>
    <div style="font-size:12px;color:#aaa;margin-bottom:10px;" id="invite-time-label"></div>
    <div class="invite-btns">
        <button style="background:#4CAF50;" onclick="acceptInvitePopup()">âœ… Accept</button>
        <button style="background:#f44336;" onclick="declineInvitePopup()">âŒ Decline</button>
    </div>
</div>

<!-- â•â•â• GAME END POPUP â•â•â• -->
<div id="game-end-overlay">
    <div id="game-end-popup">
        <div class="result-icon" id="popup-icon">â™Ÿï¸</div>
        <div class="result-title" id="popup-title">Game Over</div>
        <div class="result-sub" id="popup-sub"></div>
        <div class="popup-buttons" id="popup-buttons"></div>
    </div>
</div>

<!-- â•â•â• PROMOTION PICKER â•â•â• -->
<div id="promo-overlay">
    <div id="promo-box">
        <p>Choose promotion piece</p>
        <div class="promo-choices" id="promo-choices"></div>
    </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<!-- Socket.io client â€” loaded from your server URL -->
<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   !! CHANGE THIS TO YOUR RENDER.COM SERVER URL !!
   Example: const SERVER_URL = 'https://my-chess-server.onrender.com';
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SERVER_URL = 'https://chess-server-2ltl.onrender.com';
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let board, game = new Chess();
let socket = null;
let myColor = null, myKey = null, oppKey = null;
let currentRoomId = null;
let sourceSquare = null;

// Premove state
let premoveQueue = [];
let pmSelectSrc  = null;
let pmSimGame    = null;

// Timer state
let timeControl = 0, timers = {w:0,b:0}, timerInterval = null;
let score = {me:0,draw:0,opp:0};
let chatOpen = false;

// Friends
let friendList = [];
let isSpectating = false;

// Pending invite
let pendingInvite = null; // {from, time}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOCKET.IO CONNECTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function initSocket() {
    if (socket) socket.disconnect();
    socket = io(SERVER_URL, { transports: ['websocket', 'polling'] });

    socket.on('connect', () => {
        console.log('Connected to server');
        if (myKey) {
            socket.emit('login', myKey, (res) => {
                if (!res.ok) console.error('Login failed:', res.error);
            });
        }
    });

    socket.on('connect_error', (err) => {
        console.error('Connection error:', err);
        document.getElementById('status').innerText = 'âŒ Cannot connect to server. Check SERVER_URL.';
    });

    socket.on('disconnect', () => {
        console.log('Disconnected');
    });

    // Incoming game invite
    socket.on('invite', ({ from, time }) => {
        pendingInvite = { from, time };
        const tcLabel = time === 0 ? 'Unlimited' : time === 60 ? '1 min' : time === 180 ? '3 min' : time === 300 ? '5 min' : time === 600 ? '10 min' : `${time}s`;
        document.getElementById('invite-from-name').textContent = from;
        document.getElementById('invite-time-label').textContent = 'Time: ' + tcLabel;
        document.getElementById('invite-popup').classList.add('show');
    });

    socket.on('invite_declined', ({ from }) => {
        addChatMessage(from + ' declined your invite.', 'sys');
    });

    // Game starts
    socket.on('game_start', ({ roomId, white, black, time }) => {
        currentRoomId = roomId;
        myColor = (white === myKey) ? 'w' : 'b';
        oppKey = (white === myKey) ? black : white;
        board.orientation(myColor === 'w' ? 'white' : 'black');
        document.getElementById('time-control').value = String(time);
        resetGame(time);
        updatePlayerLabels(); updateScoreUI();
        addChatMessage('Game started! Good luck ğŸ¤', 'sys');
        enterGameMode();
    });

    // Opponent move
    socket.on('move', ({ move, timeRemaining }) => {
        const oppClr = myColor === 'w' ? 'b' : 'w';
        if (timeRemaining !== undefined) timers[oppClr] = timeRemaining;
        receiveOpponentMove(move);
    });

    // Chat
    socket.on('chat', ({ from, text }) => {
        sounds.notify.currentTime = 0; sounds.notify.play().catch(() => {});
        addChatMessage(text, 'them');
    });

    // Opponent resigned
    socket.on('opponent_resigned', () => {
        clearInterval(timerInterval);
        score.me++; updateScoreUI();
        sounds.gameEnd.play().catch(() => {});
        showGameEndPopup('ğŸ†', 'You Win!', (oppKey || 'Opponent') + ' resigned.', true);
        document.getElementById('status').innerText = (oppKey || 'Opponent') + ' resigned!';
    });

    // Opponent disconnected
    socket.on('opponent_disconnected', () => {
        addChatMessage((oppKey || 'Opponent') + ' disconnected.', 'sys');
    });

    // Rematch
    socket.on('rematch_request', ({ time }) => { showRematchOffer(time); });
    socket.on('rematch_accept',  ({ time, yourColor }) => {
        closePopup();
        myColor = yourColor;
        board.orientation(myColor === 'w' ? 'white' : 'black');
        resetGame(time); updatePlayerLabels();
        addChatMessage('Rematch started!', 'sys');
    });
    socket.on('rematch_decline', () => {
        addChatMessage((oppKey || 'Opponent') + ' declined rematch.', 'sys');
        closePopup();
    });

    // â”€â”€ Voice Call Signaling â”€â”€
    socket.on('voice_call_incoming', ({ from }) => {
        document.getElementById('caller-name').textContent = from;
        document.getElementById('call-popup').classList.add('show');
    });

    socket.on('voice_call_accepted', () => {
        // Other side accepted â€” we (caller) now create & send the WebRTC offer
        addChatMessage('ğŸ“ Connecting callâ€¦', 'sys');
        callerCreateOffer();
    });

    socket.on('voice_call_rejected', () => {
        addChatMessage((oppKey || 'Opponent') + ' declined the call.', 'sys');
        cleanupCall();
    });

    socket.on('voice_call_ended', () => {
        addChatMessage((oppKey || 'Opponent') + ' ended the call.', 'sys');
        cleanupCall();
    });

    socket.on('webrtc_offer', async ({ offer }) => {
        // We are the CALLEE receiving the offer
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            await flushIceBuffer(); // apply any ICE candidates that arrived early
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('webrtc_answer', { roomId: currentRoomId, answer });
        } catch(e) { console.error('webrtc_offer error', e); }
    });

    socket.on('webrtc_answer', async ({ answer }) => {
        // We are the CALLER receiving the answer
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            await flushIceBuffer(); // apply any ICE candidates that arrived early
        } catch(e) { console.error('webrtc_answer error', e); }
    });

    socket.on('webrtc_ice', async ({ candidate }) => {
        if (!candidate) return;
        if (peerConnection && peerConnection.remoteDescription) {
            try { await peerConnection.addIceCandidate(new RTCIceCandidate(candidate)); } catch(e) {}
        } else {
            // Buffer it â€” remoteDescription not set yet
            iceCandidateBuffer.push(candidate);
        }
    });

    // Presence updates
    socket.on('presence', ({ username, status }) => {
        updateFriendStatus(username, status);
    });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUNDS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const sounds = {
    move:    new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-self.mp3'),
    capture: new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/capture.mp3'),
    check:   new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-check.mp3'),
    gameEnd: new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/game-end.mp3'),
    notify:  new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-opponent.mp3'),
    premove: new Audio('https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/premove.mp3')
};
function playSound(mv) {
    let s = sounds.move;
    if (game.in_checkmate() || game.in_draw()) s = sounds.gameEnd;
    else if (game.in_check()) s = sounds.check;
    else if (mv && (mv.flags.includes('c') || mv.flags.includes('e'))) s = sounds.capture;
    s.currentTime = 0; s.play().catch(() => {});
}
function triggerInvalidFeedback() { if (navigator.vibrate) navigator.vibrate([60, 40, 60]); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LOGIN / USERNAME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function sanitizeKey(r) { return r.toLowerCase().replace(/[^a-z0-9_-]/g, '').slice(0, 32); }

function setMyKey() {
    const key = sanitizeKey(document.getElementById('my-key-input').value.trim());
    if (key.length < 3) return alert('Username must be 3+ characters.');
    myKey = key;
    localStorage.setItem('chess_username', key);

    if (!socket || !socket.connected) {
        initSocket();
        // Login will happen on connect event
    } else {
        socket.emit('login', key, (res) => {
            if (!res.ok) return alert('Could not connect: ' + (res.error || 'unknown error'));
            showLobby();
            setTimeout(pingAllFriends, 500);
        });
    }
}

function showLobby() {
    document.getElementById('setup-login').style.display = 'none';
    document.getElementById('setup-lobby').style.display = 'block';
    document.getElementById('lobby-name').textContent = myKey;
    document.getElementById('lobby-avatar').textContent = myKey[0].toUpperCase();
    document.getElementById('drawer-logged-out').style.display = 'none';
    document.getElementById('drawer-logged-in').style.display = 'block';
    document.getElementById('drawer-display-name').textContent = myKey;
    document.getElementById('drawer-avatar').textContent = myKey[0].toUpperCase();
}

function drawerLogin(silent = false) {
    const inp = document.getElementById('drawer-username-input');
    const key = sanitizeKey(inp.value.trim());
    if (key.length < 3) { if (!silent) alert('Username must be 3+ characters.'); return; }
    document.getElementById('my-key-input').value = key;
    setMyKey();
    if (!silent) toggleDrawer();
}

function doLogout() {
    localStorage.removeItem('chess_username');
    myKey = null;
    if (socket) socket.disconnect();
    document.getElementById('drawer-logged-out').style.display = 'block';
    document.getElementById('drawer-logged-in').style.display = 'none';
    document.getElementById('setup-login').style.display = 'block';
    document.getElementById('setup-lobby').style.display = 'none';
}

function loadSavedLogin() {
    const saved = localStorage.getItem('chess_username');
    if (saved) {
        document.getElementById('my-key-input').value = saved;
        document.getElementById('drawer-username-input').value = saved;
        myKey = sanitizeKey(saved);
        initSocket();
    }
    const savedFriends = localStorage.getItem('chess_friends');
    if (savedFriends) {
        try { friendList = JSON.parse(savedFriends); } catch (e) { friendList = []; }
    }
    renderFriendList();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONNECT TO FRIEND
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function connectToFriend() {
    if (!socket || !socket.connected || !myKey) return alert('Please log in first.');
    const id = sanitizeKey(document.getElementById('friend-id').value.trim());
    if (!id || id.length < 3) return alert('Enter your friend\'s username.');
    if (id === myKey) return alert('You cannot connect to yourself!');
    const tc = parseInt(document.getElementById('time-control').value);

    socket.emit('invite', { to: id, time: tc }, (res) => {
        if (!res.ok) return alert('Could not reach ' + id + '. They may be offline.');
        addChatMessage('Invite sent to ' + id + 'â€¦', 'sys');
    });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INVITE LINK SYSTEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function createInviteLink() {
    if (!myKey || !socket || !socket.connected) {
        alert('Please log in first.');
        return;
    }
    const tc = parseInt(document.getElementById('time-control').value);
    socket.emit('host_game', { time: tc }, (res) => {
        if (!res.ok) return alert('Error creating game.');
        document.getElementById('invite-code-display').textContent = myKey;
        const base = window.location.href.split('#')[0].split('?')[0];
        const link = `${base}#join:${myKey}:${tc}`;
        document.getElementById('invite-link-input').value = link;
        document.getElementById('invite-link-box').style.display = 'block';
        document.getElementById('create-link-btn').style.display = 'none';
        document.getElementById('invite-waiting').style.display = 'block';
    });
}

function copyGameCode() {
    const code = document.getElementById('invite-code-display').textContent;
    navigator.clipboard.writeText(code).then(() => {
        const btn = document.getElementById('copy-code-btn');
        btn.textContent = 'âœ“ Copied!';
        setTimeout(() => btn.textContent = 'ğŸ“‹ Copy Code', 2000);
    });
}

function shareInviteLink() {
    const link = document.getElementById('invite-link-input').value;
    if (navigator.share) {
        navigator.share({ title: 'â™Ÿ Chess â€“ Join my game!', text: `${myKey} challenged you!`, url: link }).catch(() => {
            navigator.clipboard.writeText(link);
        });
    } else {
        navigator.clipboard.writeText(link);
        alert('Link copied!');
    }
}

function cancelInviteLink() {
    document.getElementById('invite-link-box').style.display = 'none';
    document.getElementById('create-link-btn').style.display = 'block';
    document.getElementById('invite-waiting').style.display = 'none';
    history.replaceState(null, '', window.location.pathname + window.location.search);
}

function checkInviteLink() {
    const hash = window.location.hash;
    if (!hash.startsWith('#join:')) return;
    history.replaceState(null, '', window.location.pathname + window.location.search);
    const parts = hash.slice(1).split(':');
    if (parts.length < 2) return;
    const host = sanitizeKey(parts[1]);
    const tc   = parseInt(parts[2]) || 0;
    if (!host || host.length < 3) return;
    showJoinPrompt(host, tc);
}

function showJoinPrompt(host, tc) {
    const tcLabel = tc === 0 ? 'Unlimited' : tc === 60 ? '1 min' : tc === 180 ? '3 min' : tc === 300 ? '5 min' : tc === 600 ? '10 min' : `${tc}s`;
    const overlay = document.createElement('div');
    overlay.id = 'join-invite-overlay';
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:2000;display:flex;align-items:center;justify-content:center;';
    overlay.innerHTML = `
        <div style="background:#2a2a2a;border-radius:18px;padding:28px 24px;width:300px;text-align:center;box-shadow:0 8px 40px rgba(0,0,0,0.8);">
            <div style="font-size:42px;margin-bottom:10px;">â™Ÿï¸</div>
            <div style="font-size:18px;font-weight:bold;color:#eee;margin-bottom:6px;"><b style="color:#4CAF50">${host}</b> challenged you!</div>
            <div style="font-size:13px;color:#aaa;margin-bottom:20px;">Time: ${tcLabel}</div>
            <div style="font-size:12px;color:#888;margin-bottom:12px;">Enter your username to join:</div>
            <input type="text" id="join-username-input" placeholder="Your usernameâ€¦" maxlength="32"
                style="width:100%;padding:10px;border-radius:8px;border:none;background:#111;color:white;font-size:14px;margin-bottom:12px;text-align:center;"
                onkeydown="if(event.key==='Enter')acceptLinkInvite('${host}',${tc})">
            <div style="display:flex;gap:8px;">
                <button onclick="acceptLinkInvite('${host}',${tc})" style="flex:1;padding:12px;font-size:14px;border-radius:8px;background:#4CAF50;color:white;border:none;">âœ… Join Game</button>
                <button onclick="document.getElementById('join-invite-overlay').remove()" style="flex:1;padding:12px;font-size:14px;border-radius:8px;background:#555;color:white;border:none;">âœ• Decline</button>
            </div>
        </div>`;
    document.body.appendChild(overlay);
    const saved = localStorage.getItem('chess_username');
    if (saved) document.getElementById('join-username-input').value = saved;
    document.getElementById('join-username-input').focus();
}

function acceptLinkInvite(host, tc) {
    const inp = document.getElementById('join-username-input');
    const key = sanitizeKey(inp.value.trim());
    if (key.length < 3) { inp.style.border = '1px solid #f44336'; inp.focus(); return; }
    if (key === sanitizeKey(host)) { inp.style.border = '1px solid #f44336'; alert('Pick a different username!'); return; }

    const ov = document.getElementById('join-invite-overlay');
    if (ov) ov.remove();

    document.getElementById('my-key-input').value = key;
    document.getElementById('drawer-username-input').value = key;
    localStorage.setItem('chess_username', key);
    myKey = key;

    if (!socket || !socket.connected) {
        initSocket();
        const waitAndJoin = setInterval(() => {
            if (socket && socket.connected) {
                clearInterval(waitAndJoin);
                socket.emit('login', key, (res) => {
                    if (res.ok) {
                        showLobby();
                        doJoinGame(host, tc);
                    }
                });
            }
        }, 200);
    } else {
        socket.emit('login', key, (res) => {
            if (res.ok) {
                showLobby();
                doJoinGame(host, tc);
            }
        });
    }
}

function doJoinGame(host, tc) {
    socket.emit('join_game', { code: host, time: tc }, (res) => {
        if (!res.ok) alert('Could not join: ' + (res.error || 'Host not found'));
    });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INVITE POPUP (incoming invite)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function acceptInvitePopup() {
    if (!pendingInvite) return;
    document.getElementById('invite-popup').classList.remove('show');
    const { from, time } = pendingInvite;
    pendingInvite = null;
    socket.emit('accept_invite', { from, time });
}

function declineInvitePopup() {
    document.getElementById('invite-popup').classList.remove('show');
    if (!pendingInvite) return;
    socket.emit('decline_invite', { to: pendingInvite.from });
    pendingInvite = null;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FRIENDS & PRESENCE SYSTEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function pingAllFriends() {
    if (!socket || !socket.connected) return;
    friendList.forEach(f => pingFriend(f.username));
}

function pingFriend(username) {
    if (!socket || !socket.connected) return;
    socket.emit('ping_user', username, ({ status }) => {
        updateFriendStatus(username, status);
    });
}

function addFriend() {
    const inp = document.getElementById('add-friend-input');
    const key = sanitizeKey(inp.value.trim());
    if (key.length < 3) return alert('Enter a valid username.');
    if (key === myKey) return alert("That's you!");
    if (friendList.find(f => f.username === key)) return alert('Already in your list.');
    friendList.push({ username: key, status: 'offline' });
    saveFriends();
    inp.value = '';
    pingFriend(key);
    renderFriendList();
}

function removeFriend(username) {
    friendList = friendList.filter(f => f.username !== username);
    saveFriends();
    renderFriendList();
}

function saveFriends() {
    localStorage.setItem('chess_friends', JSON.stringify(friendList));
}

function updateFriendStatus(username, status) {
    const f = friendList.find(f => f.username === username);
    if (f) { f.status = status; saveFriends(); }
    renderFriendList();
    updateFriendsBadge();
}

function updateFriendsBadge() {
    const onlineCount = friendList.filter(f => f.status !== 'offline').length;
    const badge = document.getElementById('friends-badge');
    if (onlineCount > 0) {
        badge.textContent = onlineCount;
        badge.style.display = 'inline';
    } else {
        badge.style.display = 'none';
    }
}

function spectateUser(username) {
    if (!socket || !socket.connected) return alert('Please log in first.');
    socket.emit('spectate', { username }, ({ ok, white, black, fen, error }) => {
        if (!ok) return alert(error || username + ' is not in a game.');
        isSpectating = true;
        document.getElementById('spectate-banner-name').textContent = username;
        document.getElementById('spectate-banner').classList.add('show');
        if (fen && fen !== 'start') board.position(fen, false);
        if (white && black) {
            document.getElementById('opp-name').textContent = black;
            document.getElementById('me-name').textContent = white;
        }
        toggleDrawer();
    });
}

function spectateByInput() {
    const inp = document.getElementById('spectate-input');
    const key = sanitizeKey(inp.value.trim());
    if (key.length < 3) return alert('Enter a valid username.');
    inp.value = '';
    if (!friendList.find(f => f.username === key)) {
        friendList.push({ username: key, status: 'offline' });
        saveFriends();
        renderFriendList();
    }
    spectateUser(key);
}

function stopSpectating() {
    isSpectating = false;
    document.getElementById('spectate-banner').classList.remove('show');
    resetGame(0);
    exitGameMode();
}

function renderFriendList() {
    const list = document.getElementById('friend-list');
    const empty = document.getElementById('empty-friends-msg');
    list.querySelectorAll('.friend-item').forEach(el => el.remove());

    if (friendList.length === 0) { empty.style.display = 'block'; updateFriendsBadge(); return; }
    empty.style.display = 'none';

    const sorted = [...friendList].sort((a, b) => {
        const rank = { playing: 0, online: 1, offline: 2 };
        return (rank[a.status] || 2) - (rank[b.status] || 2);
    });

    sorted.forEach(f => {
        const statusLabel = f.status === 'playing' ? 'â™Ÿ In a game' : f.status === 'online' ? 'ğŸŸ¢ Online' : 'âš« Offline';
        const colors = ['#e53935','#1E88E5','#8E24AA','#00897B','#F4511E','#6D4C41'];
        const color = colors[f.username.charCodeAt(0) % colors.length];
        const item = document.createElement('div');
        item.className = 'friend-item';
        item.innerHTML = `
            <div class="status-dot ${f.status}"></div>
            <div class="friend-avatar" style="background:${color}">${f.username[0].toUpperCase()}</div>
            <div class="friend-info">
                <div class="friend-name">${f.username}</div>
                <div class="friend-status ${f.status}">${statusLabel}</div>
            </div>
            <div class="friend-actions">
                ${f.status === 'playing' ? `<button class="btn-spectate-friend" onclick="spectateUser('${f.username}')">ğŸ‘ Watch</button>` : ''}
                ${f.status !== 'offline' ? `<button class="btn-play-friend" onclick="playFriend('${f.username}')">â–¶ Play</button>` : ''}
                <button class="btn-remove-friend" onclick="removeFriend('${f.username}')">âœ•</button>
            </div>`;
        list.appendChild(item);
    });
    updateFriendsBadge();
}

function playFriend(username) {
    document.getElementById('friend-id').value = username;
    toggleDrawer();
    connectToFriend();
}

function toggleDrawer() {
    const drawer = document.getElementById('friends-drawer');
    const overlay = document.getElementById('drawer-overlay');
    const isOpen = drawer.classList.contains('open');
    drawer.classList.toggle('open');
    overlay.classList.toggle('show');
    if (!isOpen) { pingAllFriends(); renderFriendList(); }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VOICE CALL  (WebRTC â€” clean rewrite)
   Flow:
     Caller  â†’ startCall() â†’ gets mic â†’ emits voice_call_request
     Callee  â† voice_call_incoming â†’ shows popup
     Callee  â†’ answerCall() â†’ gets mic â†’ creates RTCPeer â†’ emits voice_call_accept
     Caller  â† voice_call_accepted â†’ callerCreateOffer() â†’ sends webrtc_offer
     Callee  â† webrtc_offer â†’ setRemote â†’ createAnswer â†’ sends webrtc_answer
     Caller  â† webrtc_answer â†’ setRemote â†’ ICE flows â†’ audio connects!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let localStream = null, peerConnection = null, isMuted = false, inCall = false, isCaller = false;
// Buffer ICE candidates that arrive before remoteDescription is set
let iceCandidateBuffer = [];

const ICE_SERVERS = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        // Free Open Relay TURN â€” works even behind strict firewalls
        { urls: 'turn:openrelay.metered.ca:80',                   username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443',                  username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443?transport=tcp',    username: 'openrelayproject', credential: 'openrelayproject' }
    ]
};

function showCallBtn(show) {
    document.getElementById('call-btn').classList.toggle('visible', show);
}
function handleCallBtn() {
    if (inCall) hangupCall(); else startCall();
}
function updateCallBtn() {
    const btn = document.getElementById('call-btn');
    btn.textContent = inCall ? 'ğŸ“µ End Call' : 'ğŸ“ Call';
    btn.classList.toggle('in-call', inCall);
}

// â”€â”€ STEP 1: Caller taps Call â”€â”€
async function startCall() {
    if (!socket || !socket.connected || !currentRoomId) return alert('Connect to a friend first.');
    if (inCall) return;
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    } catch (e) {
        return alert('âŒ Microphone access denied.\nPlease allow mic in your browser settings and try again.');
    }
    isCaller = true;
    iceCandidateBuffer = [];
    createPeerConnection(); // create early so ICE buffer works
    socket.emit('voice_call_request', { roomId: currentRoomId });
    addChatMessage('ğŸ“ Calling ' + (oppKey || 'opponent') + 'â€¦', 'sys');
}

// â”€â”€ STEP 2: Callee taps Answer â”€â”€
async function answerCall() {
    document.getElementById('call-popup').classList.remove('show');
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    } catch (e) {
        return alert('âŒ Microphone access denied.');
    }
    isCaller = false;
    iceCandidateBuffer = [];
    createPeerConnection(); // ready before offer arrives
    socket.emit('voice_call_accept', { roomId: currentRoomId });
}

// â”€â”€ STEP 3: Caller hears accepted â†’ creates offer â”€â”€
async function callerCreateOffer() {
    if (!peerConnection) return;
    try {
        const offer = await peerConnection.createOffer({ offerToReceiveAudio: true });
        await peerConnection.setLocalDescription(offer);
        socket.emit('webrtc_offer', { roomId: currentRoomId, offer });
    } catch(e) { console.error('createOffer error', e); cleanupCall(); }
}

function rejectCall() {
    document.getElementById('call-popup').classList.remove('show');
    if (socket && currentRoomId) socket.emit('voice_call_reject', { roomId: currentRoomId });
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
}

// â”€â”€ Create RTCPeerConnection with all handlers â”€â”€
function createPeerConnection() {
    if (peerConnection) { try { peerConnection.close(); } catch(e){} }
    peerConnection = new RTCPeerConnection(ICE_SERVERS);

    // Add our mic tracks
    if (localStream) {
        localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));
    }

    // Remote audio arrives â†’ play it
    peerConnection.ontrack = (event) => {
        console.log('ontrack fired', event.streams);
        const audio = document.getElementById('remote-audio');
        audio.srcObject = event.streams[0];
        audio.play().catch(e => console.warn('autoplay blocked:', e));
        inCall = true;
        document.getElementById('voice-bar').classList.add('show');
        document.getElementById('voice-status-text').textContent = 'ğŸ™ In call with ' + (oppKey || 'opponent');
        updateCallBtn();
        addChatMessage('ğŸ™ Call connected!', 'sys');
    };

    // ICE candidate ready â†’ send to other side
    peerConnection.onicecandidate = (event) => {
        if (event.candidate && socket && currentRoomId) {
            socket.emit('webrtc_ice', { roomId: currentRoomId, candidate: event.candidate });
        }
    };

    peerConnection.onconnectionstatechange = () => {
        const s = peerConnection ? peerConnection.connectionState : '';
        console.log('WebRTC state:', s);
        if (s === 'connected') {
            inCall = true; updateCallBtn();
        }
        if (s === 'disconnected' || s === 'failed' || s === 'closed') {
            if (inCall) { cleanupCall(); addChatMessage('ğŸ“µ Call disconnected.', 'sys'); }
        }
    };
}

// â”€â”€ Flush buffered ICE candidates after remoteDescription is set â”€â”€
async function flushIceBuffer() {
    while (iceCandidateBuffer.length > 0) {
        const c = iceCandidateBuffer.shift();
        try { await peerConnection.addIceCandidate(new RTCIceCandidate(c)); } catch(e) {}
    }
}

function hangupCall() {
    if (socket && socket.connected && currentRoomId) socket.emit('voice_call_end', { roomId: currentRoomId });
    cleanupCall();
    addChatMessage('ğŸ“µ You ended the call.', 'sys');
}

function cleanupCall() {
    inCall = false; isCaller = false; isMuted = false; iceCandidateBuffer = [];
    if (peerConnection) { try { peerConnection.close(); } catch(e){} peerConnection = null; }
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    const audio = document.getElementById('remote-audio');
    if (audio) audio.srcObject = null;
    document.getElementById('voice-bar').classList.remove('show');
    document.getElementById('mute-btn').textContent = 'ğŸ™ Mute';
    document.getElementById('mute-btn').classList.remove('muted');
    updateCallBtn();
}

function toggleMute() {
    if (!localStream) return;
    isMuted = !isMuted;
    localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
    const btn = document.getElementById('mute-btn');
    btn.textContent = isMuted ? 'ğŸ”‡ Unmute' : 'ğŸ™ Mute';
    btn.classList.toggle('muted', isMuted);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME MODE UI
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function enterGameMode() {
    document.getElementById('setup-panel').style.display = 'none';
    document.getElementById('ingame-panel').style.display = 'block';
    document.getElementById('game-actions').style.display = 'flex';
    if (currentRoomId) {
        document.getElementById('chat-section').style.display = 'block';
        showCallBtn(true);
        updateCallBtn();
        showScoreBar(true);
    }
}

function exitGameMode() {
    document.getElementById('setup-panel').style.display = 'block';
    document.getElementById('ingame-panel').style.display = 'none';
    document.getElementById('chat-section').style.display = 'none';
    showScoreBar(false);
    if (myKey) {
        document.getElementById('setup-login').style.display = 'none';
        document.getElementById('setup-lobby').style.display = 'block';
    } else {
        document.getElementById('setup-login').style.display = 'block';
        document.getElementById('setup-lobby').style.display = 'none';
    }
}

function startLocalGame() {
    myColor = null; currentRoomId = null; oppKey = null;
    resetGame(0);
    document.getElementById('me-name').textContent  = 'White';
    document.getElementById('opp-name').textContent = 'Black';
    document.getElementById('me-dot').className  = 'color-dot white';
    document.getElementById('opp-dot').className = 'color-dot black';
    document.getElementById('status').innerText = 'White to move';
    enterGameMode();
}

function updatePlayerLabels() {
    const me = myKey || 'You', opp = oppKey || 'Opponent';
    document.getElementById('me-name').textContent  = me;
    document.getElementById('opp-name').textContent = opp;
    if (myColor === 'w') {
        document.getElementById('me-dot').className  = 'color-dot white';
        document.getElementById('opp-dot').className = 'color-dot black';
    } else if (myColor === 'b') {
        document.getElementById('me-dot').className  = 'color-dot black';
        document.getElementById('opp-dot').className = 'color-dot white';
    } else {
        document.getElementById('me-dot').className  = 'color-dot white';
        document.getElementById('opp-dot').className = 'color-dot black';
    }
    document.getElementById('score-label-me').textContent  = me;
    document.getElementById('score-label-opp').textContent = opp;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CHAT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function toggleChat() {
    chatOpen = !chatOpen;
    document.getElementById('chat-body').style.display = chatOpen ? 'block' : 'none';
    document.getElementById('chat-arrow').textContent = chatOpen ? 'â–²' : 'â–¼';
    if (chatOpen) { document.getElementById('chat-badge').style.display = 'none'; const m = document.getElementById('chat-messages'); m.scrollTop = m.scrollHeight; }
}
function addChatMessage(text, who) {
    const msgs = document.getElementById('chat-messages');
    const div = document.createElement('div'); div.className = 'chat-msg';
    if (who === 'sys') { div.innerHTML = `<span class="sys">${text}</span>`; }
    else { const lbl = who === 'you' ? (myKey || 'You') : (oppKey || 'Opponent'); div.innerHTML = `<span class="${who}"><b>${lbl}:</b> ${text}</span>`; }
    msgs.appendChild(div); msgs.scrollTop = msgs.scrollHeight;
    if (who === 'them' && !chatOpen) document.getElementById('chat-badge').style.display = 'inline';
}
function sendChat() {
    const inp = document.getElementById('chat-input'); const txt = inp.value.trim();
    if (!txt || !socket || !socket.connected || !currentRoomId) return;
    socket.emit('chat', { roomId: currentRoomId, text: txt });
    addChatMessage(txt, 'you'); inp.value = '';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TIMERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function formatTime(s) {
    if (s <= 0) return '0:00';
    return Math.floor(s / 60) + ':' + (s % 60 < 10 ? '0' : '') + (s % 60);
}
function updateTimersUI() {
    if (timeControl === 0) { $('#player-timer,#opponent-timer').text('âˆ'); return; }
    $('#player-timer').text(formatTime(timers[myColor || 'w']));
    $('#opponent-timer').text(formatTime(timers[myColor === 'w' ? 'b' : 'w']));
}
function checkStartClock() {
    if (!timerInterval && timeControl > 0 && game.history().length > 0) {
        timerInterval = setInterval(() => {
            if (game.game_over()) return clearInterval(timerInterval);
            timers[game.turn()]--;
            updateTimersUI();
            if (timers[game.turn()] <= 0) { clearInterval(timerInterval); sounds.gameEnd.play().catch(() => {}); handleGameOver(); }
        }, 1000);
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME MANAGEMENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function resetGame(tcTime) {
    game = new Chess();
    board.position('start', true);
    document.getElementById('board').classList.remove('pieces-flipped');
    timeControl = tcTime;
    timers = { w: tcTime, b: tcTime };
    clearInterval(timerInterval); timerInterval = null;
    clearVisuals();
    cancelAllPremoves();
    sourceSquare = null;
    updateMaterial();
    $('.square-55d63').removeClass('last-move king-in-check');
    updateTimersUI(); updateStatus();
}

function handleGameOver() {
    const timeLoss = timeControl > 0 && (timers.w <= 0 || timers.b <= 0);
    if (!game.game_over() && !timeLoss) return;
    cancelAllPremoves();
    let icon, title, sub;
    if (game.in_checkmate()) {
        const loser = game.turn();
        if (myColor) { if (loser !== myColor) { icon = 'ğŸ†'; title = 'You Win!'; sub = 'Checkmate!'; score.me++; } else { icon = 'ğŸ˜”'; title = 'You Lost'; sub = 'Checkmate.'; score.opp++; } }
        else { icon = 'â™Ÿï¸'; title = 'Checkmate!'; sub = (loser === 'w' ? 'Black' : 'White') + ' wins.'; }
    } else if (game.in_draw()) {
        icon = 'ğŸ¤'; title = 'Draw'; sub = 'Game drawn.'; if (myColor) score.draw++;
    } else if (timeLoss) {
        const timedOut = timers.w <= 0 ? 'w' : 'b';
        if (myColor) { if (timedOut === myColor) { icon = 'â°'; title = 'Time Out'; sub = 'You ran out of time.'; score.opp++; } else { icon = 'ğŸ†'; title = 'You Win!'; sub = (oppKey || 'Opponent') + ' timed out!'; score.me++; } }
        else { icon = 'â°'; title = 'Time'; sub = (timedOut === 'w' ? 'White' : 'Black') + ' timed out.'; }
    }
    if (icon) { updateScoreUI(); showGameEndPopup(icon, title, sub, true); }
}

function exportPGN() {
    const pgn = game.pgn();
    if (!pgn) return alert('No moves yet!');
    navigator.clipboard.writeText(pgn).then(() => alert('PGN copied!'));
}

function resignGame() {
    if (game.game_over()) return;
    if (socket && socket.connected && currentRoomId) socket.emit('resign', { roomId: currentRoomId });
    clearInterval(timerInterval);
    cancelAllPremoves();
    score.opp++; updateScoreUI();
    sounds.gameEnd.play().catch(() => {});
    document.getElementById('status').innerText = 'You Resigned.';
    showGameEndPopup('ğŸ˜”', 'You Resigned', currentRoomId ? 'Want to try again?' : '', true);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VISUALS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateCheckHighlight() {
    $('#board .square-55d63').removeClass('king-in-check');
    if (!game.in_check()) return;
    const turn = game.turn(), b = game.board();
    for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = b[r][c];
        if (p && p.type === 'k' && p.color === turn) {
            $('#board .square-' + (String.fromCharCode(97 + c)) + (8 - r)).addClass('king-in-check');
            return;
        }
    }
}
function updateLastMoveVisuals(mv) {
    $('.square-55d63').removeClass('last-move');
    if (mv) { $('.square-' + mv.from).addClass('last-move'); $('.square-' + mv.to).addClass('last-move'); }
    updateMaterial();
}
function showLegalMoves(sq) {
    game.moves({ square: sq, verbose: true }).forEach(m => {
        const cap = m.flags.includes('c') || m.flags.includes('e');
        $('#board .square-' + m.to).addClass(cap ? 'legal-move-capture' : 'legal-move');
    });
}
function highlightSquare(sq, cls) {
    if (cls === 'highlight-square') $('#board .square-55d63').removeClass('highlight-square');
    $('#board .square-' + sq).addClass(cls);
}
function clearLegalMoves() { $('#board .square-55d63').removeClass('legal-move legal-move-capture'); }
function clearVisuals() { $('#board .square-55d63').removeClass('highlight-square'); clearLegalMoves(); }

function updateStatus() {
    const el = document.getElementById('status');
    if (timeControl > 0) { if (timers.w <= 0) return el.innerText = 'Black Wins on Time!'; if (timers.b <= 0) return el.innerText = 'White Wins on Time!'; }
    if (game.in_checkmate()) return el.innerText = 'Checkmate!';
    if (game.in_draw()) return el.innerText = 'Draw!';
    if (!currentRoomId) { el.innerText = 'Local Mode: ' + (game.turn() === 'w' ? 'White' : 'Black') + ' to move'; return; }
    el.innerText = game.turn() === myColor ? 'Your Turn' : (oppKey || 'Opponent') + "'s Turn";
}

function showScoreBar(show) { document.getElementById('score-bar').style.display = show ? 'block' : 'none'; }
function updateScoreUI() {
    document.getElementById('score-me').textContent = score.me;
    document.getElementById('score-draw').textContent = score.draw;
    document.getElementById('score-opp').textContent = score.opp;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MATERIAL COUNT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9 };
function updateMaterial() {
    const count = { w: { p: 0, n: 0, b: 0, r: 0, q: 0 }, b: { p: 0, n: 0, b: 0, r: 0, q: 0 } };
    const boardState = game.board();
    for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = boardState[r][c];
        if (p && p.type !== 'k') count[p.color][p.type]++;
    }
    const START = { p: 8, n: 2, b: 2, r: 2, q: 1 };
    const whiteCaptured = {}, blackCaptured = {};
    let whiteVal = 0, blackVal = 0;
    for (const t of ['p', 'n', 'b', 'r', 'q']) {
        whiteCaptured[t] = Math.max(0, START[t] - count.b[t]);
        blackCaptured[t] = Math.max(0, START[t] - count.w[t]);
        whiteVal += whiteCaptured[t] * PIECE_VALUES[t];
        blackVal += blackCaptured[t] * PIECE_VALUES[t];
    }
    const meColor = myColor || 'w', oppColor = meColor === 'w' ? 'b' : 'w';
    const meCap = meColor === 'w' ? whiteCaptured : blackCaptured;
    const oppCap = oppColor === 'w' ? whiteCaptured : blackCaptured;
    const meScore = meColor === 'w' ? whiteVal : blackVal;
    const oppScore = oppColor === 'w' ? whiteVal : blackVal;
    renderMaterialRow('me-material', meCap, meColor, meScore - oppScore);
    renderMaterialRow('opp-material', oppCap, oppColor, oppScore - meScore);
}
function renderMaterialRow(elId, captured, capturedByColor, scoreDiff) {
    const el = document.getElementById(elId); if (!el) return;
    el.innerHTML = '';
    const imgColor = capturedByColor === 'w' ? 'b' : 'w';
    for (const type of ['p', 'n', 'b', 'r', 'q']) {
        for (let i = 0; i < (captured[type] || 0); i++) {
            const div = document.createElement('div');
            div.className = 'mat-piece';
            div.style.backgroundImage = `url('https://chessboardjs.com/img/chesspieces/wikipedia/${imgColor}${type.toUpperCase()}.png')`;
            el.appendChild(div);
        }
    }
    if (scoreDiff > 0) {
        const sc = document.createElement('span');
        sc.className = 'mat-score positive';
        sc.textContent = '+' + scoreDiff;
        el.appendChild(sc);
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   POPUP / GAME MANAGEMENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showGameEndPopup(icon, title, sub, withRematch) {
    document.getElementById('popup-icon').textContent = icon;
    document.getElementById('popup-title').textContent = title;
    document.getElementById('popup-sub').textContent = sub;
    let btns = '';
    if (withRematch && socket && socket.connected && currentRoomId) btns += `<button class="btn-rematch" onclick="requestRematch()">ğŸ”„ Rematch</button>`;
    btns += `<button class="btn-newgame" onclick="startNewGame()">â™Ÿ New Game</button>`;
    btns += `<button class="btn-close" onclick="closePopup()">âœ• Close</button>`;
    document.getElementById('popup-buttons').innerHTML = btns;
    document.getElementById('game-end-overlay').classList.add('show');
}
function closePopup() { document.getElementById('game-end-overlay').classList.remove('show'); }
function startNewGame() {
    closePopup(); myColor = null; currentRoomId = null; oppKey = null;
    resetGame(0); score = { me: 0, draw: 0, opp: 0 }; updatePlayerLabels();
    cleanupCall();
    showCallBtn(false);
    exitGameMode();
}
function requestRematch() {
    if (!socket || !socket.connected || !currentRoomId) return;
    socket.emit('rematch_request', { roomId: currentRoomId, time: timeControl });
    addChatMessage('Rematch requestedâ€¦', 'sys');
    document.getElementById('popup-buttons').innerHTML =
        `<button class="btn-rematch" disabled style="opacity:0.5">â³ Waitingâ€¦</button>
         <button class="btn-close" onclick="closePopup()">âœ• Close</button>`;
}
function showRematchOffer(tcTime) {
    document.getElementById('popup-icon').textContent = 'ğŸ”„';
    document.getElementById('popup-title').textContent = 'Rematch?';
    document.getElementById('popup-sub').textContent = (oppKey || 'Opponent') + ' wants a rematch!';
    document.getElementById('popup-buttons').innerHTML =
        `<button class="btn-rematch" onclick="acceptRematch(${tcTime})">âœ… Accept</button>
         <button class="btn-close" onclick="declineRematch()">âœ• Decline</button>`;
    document.getElementById('game-end-overlay').classList.add('show');
}
function acceptRematch(tcTime) {
    closePopup();
    myColor = myColor === 'w' ? 'b' : 'w';
    board.orientation(myColor === 'w' ? 'white' : 'black');
    resetGame(tcTime);
    socket.emit('rematch_accept', { roomId: currentRoomId, time: tcTime, yourColor: myColor === 'w' ? 'b' : 'w' });
    updatePlayerLabels(); addChatMessage('Rematch started!', 'sys');
}
function declineRematch() {
    closePopup();
    if (socket && socket.connected && currentRoomId) socket.emit('rematch_decline', { roomId: currentRoomId });
    addChatMessage('Rematch declined.', 'sys');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PREMOVE SYSTEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function cancelAllPremoves() {
    premoveQueue = []; pmSelectSrc = null; pmSimGame = null;
    clearAllGhosts();
    $('#board .square-55d63').removeClass('premove-from premove-to premove-select');
}
function isPromotion(from, to) {
    const piece = game.get(from);
    if (!piece || piece.type !== 'p') return false;
    const toRank = to[1];
    return (piece.color === 'w' && toRank === '8') || (piece.color === 'b' && toRank === '1');
}
function showPromoPicker(color, callback) {
    const pieces = ['q', 'r', 'b', 'n'];
    const names  = { q: 'Queen', r: 'Rook', b: 'Bishop', n: 'Knight' };
    const choices = document.getElementById('promo-choices');
    choices.innerHTML = '';
    pieces.forEach(p => {
        const btn = document.createElement('button');
        btn.className = 'promo-btn';
        btn.style.backgroundImage = `url('https://chessboardjs.com/img/chesspieces/wikipedia/${color}${p.toUpperCase()}.png')`;
        btn.title = names[p];
        btn.onclick = () => { document.getElementById('promo-overlay').classList.remove('show'); callback(p); };
        choices.appendChild(btn);
    });
    document.getElementById('promo-overlay').classList.add('show');
}
function rebuildSimGame() {
    const ourColor = myColor || game.turn();
    pmSimGame = new Chess(game.fen());
    for (const pm of premoveQueue) {
        if (pmSimGame.turn() !== ourColor) {
            const parts = pmSimGame.fen().split(' ');
            parts[1] = ourColor; parts[3] = '-';
            pmSimGame = new Chess(parts.join(' ')) || pmSimGame;
        }
        const r = pmSimGame.move({ from: pm.from, to: pm.to, promotion: pm.promo || 'q' });
        if (!r) break;
    }
}
function clearAllGhosts() { $('.ghost-piece').remove(); $('#board img').css('opacity', ''); }
function renderPremoveVisuals() {
    $('#board .square-55d63').removeClass('premove-from premove-to premove-select');
    clearAllGhosts();
    if (premoveQueue.length > 0) {
        const toSquares = new Set(premoveQueue.map(pm => pm.to));
        const realFroms = premoveQueue.map(pm => pm.from).filter(sq => !toSquares.has(sq));
        realFroms.forEach(sq => { $(`#board .square-${sq} img`).css('opacity', '0.2'); $(`#board .square-${sq}`).addClass('premove-from'); });
        premoveQueue.forEach(pm => {
            $(`#board .square-${pm.from}`).addClass('premove-from');
            $(`#board .square-${pm.to}`).addClass('premove-to');
            const imgUrl = `https://chessboardjs.com/img/chesspieces/wikipedia/${pm.pieceColor}${pm.pieceType.toUpperCase()}.png`;
            $('<div>').addClass('ghost-piece').css('background-image', `url('${imgUrl}')`).appendTo(`#board .square-${pm.to}`);
        });
    }
    if (pmSelectSrc) { $(`#board .square-${pmSelectSrc}`).addClass('premove-select'); $(`#board .square-${pmSelectSrc} img`).css('opacity', '0.2'); }
}
function executePremoveQueue() {
    if (premoveQueue.length === 0) return;
    if (game.game_over()) { cancelAllPremoves(); return; }
    const allowed = myColor || game.turn();
    while (premoveQueue.length > 0) {
        if (game.game_over()) { cancelAllPremoves(); break; }
        if (game.turn() !== allowed) break;
        const pm = premoveQueue.shift();
        const move = game.move({ from: pm.from, to: pm.to, promotion: pm.promo || 'q' });
        if (!move) { cancelAllPremoves(); break; }
        if (pm.loop) premoveQueue.push({ ...pm });
        if (socket && socket.connected && currentRoomId) socket.emit('move', { roomId: currentRoomId, move: move.san, timeRemaining: timers[myColor] });
        board.position(game.fen(), true);
        updateLastMoveVisuals(move); updateCheckHighlight(); playSound(move); checkStartClock(); updateStatus(); handleGameOver();
        if (game.game_over()) { cancelAllPremoves(); break; }
        if (myColor !== null) break;
    }
    rebuildSimGame(); renderPremoveVisuals();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RECEIVE OPPONENT MOVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function receiveOpponentMove(san) {
    const moveObj = game.move(san);
    if (!moveObj) return;
    board.position(game.fen(), true);
    updateLastMoveVisuals(moveObj); updateCheckHighlight(); playSound(moveObj); checkStartClock();
    const allowed = myColor || game.turn();
    if (game.turn() === allowed && premoveQueue.length > 0) {
        setTimeout(() => { executePremoveQueue(); updateStatus(); handleGameOver(); }, 50);
    } else { updateStatus(); handleGameOver(); }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BOARD CLICK HANDLING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function onSquareClick(square) {
    if (game.game_over() || (timeControl > 0 && (timers.w <= 0 || timers.b <= 0))) return;
    const allowed = myColor || game.turn();

    if (game.turn() !== allowed) {
        const simGame = pmSimGame || new Chess(game.fen());
        if (pmSelectSrc === square) { pmSelectSrc = null; renderPremoveVisuals(); return; }
        const simPiece = simGame.get(square);
        const isOurSimPiece = simPiece && simPiece.color === allowed;
        if (pmSelectSrc) {
            if (isOurSimPiece) { pmSelectSrc = square; renderPremoveVisuals(); return; }
            const movingPiece = simGame.get(pmSelectSrc);
            if (!movingPiece) { pmSelectSrc = null; renderPremoveVisuals(); return; }
            const src = pmSelectSrc; pmSelectSrc = null;
            const isPawnPromo = movingPiece.type === 'p' && ((movingPiece.color === 'w' && square[1] === '8') || (movingPiece.color === 'b' && square[1] === '1'));
            const addToQueue = (promo) => {
                premoveQueue.push({ from: src, to: square, promo, pieceType: movingPiece.type, pieceColor: movingPiece.color, loop: false });
                rebuildSimGame(); sounds.premove.currentTime = 0; sounds.premove.play().catch(() => {}); renderPremoveVisuals();
            };
            if (isPawnPromo) { showPromoPicker(movingPiece.color, addToQueue); } else { addToQueue('q'); }
            return;
        }
        if (isOurSimPiece) { pmSelectSrc = square; renderPremoveVisuals(); return; }
        cancelAllPremoves(); return;
    }

    pmSelectSrc = null;
    if (premoveQueue.length > 0 && myColor === null) cancelAllPremoves();

    if (!sourceSquare) {
        const piece = game.get(square);
        if (piece && piece.color === allowed) { sourceSquare = square; highlightSquare(square, 'highlight-square'); showLegalMoves(square); }
        else { triggerInvalidFeedback(); }
        return;
    }

    if (isPromotion(sourceSquare, square)) {
        const piece = game.get(sourceSquare);
        const savedSrc = sourceSquare;
        clearVisuals(); sourceSquare = null;
        showPromoPicker(piece.color, (promo) => {
            const move = game.move({ from: savedSrc, to: square, promotion: promo });
            if (!move) return;
            board.position(game.fen(), true);
            updateLastMoveVisuals(move); updateCheckHighlight(); playSound(move); checkStartClock();
            if (socket && socket.connected && currentRoomId) socket.emit('move', { roomId: currentRoomId, move: move.san, timeRemaining: timers[myColor] });
            if (!myColor && !game.game_over()) flipPiecesOnly();
            updateStatus(); handleGameOver();
        });
        return;
    }

    const move = game.move({ from: sourceSquare, to: square, promotion: 'q' });
    if (!move) {
        const piece = game.get(square);
        if (piece && piece.color === allowed) { sourceSquare = square; clearVisuals(); highlightSquare(square, 'highlight-square'); showLegalMoves(square); }
        else { triggerInvalidFeedback(); clearVisuals(); sourceSquare = null; }
        return;
    }

    clearVisuals(); sourceSquare = null;
    board.position(game.fen(), true);
    updateLastMoveVisuals(move); updateCheckHighlight(); playSound(move); checkStartClock();
    if (socket && socket.connected && currentRoomId) socket.emit('move', { roomId: currentRoomId, move: move.san, timeRemaining: timers[myColor] });
    if (!myColor && !game.game_over()) flipPiecesOnly();
    updateStatus(); handleGameOver();
}

function flipPiecesOnly() { document.getElementById('board').classList.toggle('pieces-flipped'); }
function flipBoard() {
    board.flip();
    const meName = document.getElementById('me-name').textContent;
    const oppName = document.getElementById('opp-name').textContent;
    const meDot = document.getElementById('me-dot').className;
    const oppDot = document.getElementById('opp-dot').className;
    document.getElementById('me-name').textContent  = oppName;
    document.getElementById('opp-name').textContent = meName;
    document.getElementById('me-dot').className  = oppDot;
    document.getElementById('opp-dot').className = meDot;
}

$('#board').on('contextmenu', e => { e.preventDefault(); cancelAllPremoves(); });
let longPressTimer = null;
$('#board').on('touchstart mousedown', '.square-55d63', function (e) {
    longPressTimer = setTimeout(() => {
        if (premoveQueue.length === 0) return;
        const last = premoveQueue[premoveQueue.length - 1];
        last.loop = !last.loop;
        if (navigator.vibrate) navigator.vibrate(last.loop ? [30, 20, 30] : [40]);
        renderPremoveVisuals();
    }, 500);
});
$('#board').on('touchend touchcancel mouseup mouseleave', () => { clearTimeout(longPressTimer); });

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
board = ChessBoard('board', {
    position: 'start', draggable: false,
    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
});
$(window).on('resize', board.resize);
$('#board').on('click', '.square-55d63', function () {
    const sq = $(this).attr('data-square'); if (sq) onSquareClick(sq);
});

updateTimersUI(); updateStatus(); updatePlayerLabels();
document.getElementById('setup-login').style.display = 'block';
document.getElementById('setup-lobby').style.display = 'none';
document.getElementById('ingame-panel').style.display = 'none';
document.getElementById('game-actions').style.display = 'none';
document.getElementById('chat-section').style.display = 'none';

loadSavedLogin();
renderFriendList();
setTimeout(checkInviteLink, 400);

// After socket connects, auto-login
if (socket) {
    socket.on('connect', () => {
        if (myKey) {
            socket.emit('login', myKey, (res) => {
                if (res.ok) {
                    showLobby();
                    setTimeout(pingAllFriends, 500);
                }
            });
        }
    });
}
</script>
</body>
</html>
